using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using 游戏服务器.地图类;
using 游戏服务器.数据类;
using 游戏服务器.网络类;

namespace 游戏服务器.模板类;

public class 技能实例
{
	public 游戏技能 技能模板;

	public 技能数据 技能数据;

	public 地图对象 技能来源;

	public byte 动作编号;

	public byte 分段编号;

	public 地图实例 释放地图;

	public 地图对象 技能目标;

	public Point 技能锚点;

	public Point 释放位置;

	public DateTime 释放时间;

	public 技能实例 父类技能;

	public bool 目标借位;

	public Dictionary<int, 命中详情> 命中列表;

	public int 飞行耗时;

	public int 攻速缩减;

	public bool 经验增加;

	public DateTime 处理计时;

	public DateTime 预约时间;

	public SortedDictionary<int, 技能任务> 节点列表;

	public int 来源编号 => 技能来源.地图编号;

	public byte 分组编号 => 技能模板.技能分组编号;

	public byte 铭文编号 => 技能模板.自身铭文编号;

	public ushort 技能编号 => 技能模板.自身技能编号;

	public byte 技能等级
	{
		get
		{
			if (技能模板.绑定等级编号 == 0)
			{
				return 0;
			}
			if (技能来源 is 玩家实例 玩家实例 && 玩家实例.主体技能表.TryGetValue(技能模板.绑定等级编号, out var v))
			{
				return v.技能等级.V;
			}
			if (技能来源 is 陷阱实例 陷阱实例 && 陷阱实例.陷阱来源 is 玩家实例 玩家实例2 && 玩家实例2.主体技能表.TryGetValue(技能模板.绑定等级编号, out var v2))
			{
				return v2.技能等级.V;
			}
			return 0;
		}
	}

	public bool 检查计数 => 技能模板.检查技能计数;

	public 技能实例(地图对象 技能来源, 游戏技能 技能模板, 技能数据 技能数据, byte 动作编号, 地图实例 释放地图, Point 释放位置, 地图对象 技能目标, Point 技能锚点, 技能实例 父类技能, Dictionary<int, 命中详情> 命中列表 = null, bool 目标借位 = false)
	{
		this.技能来源 = 技能来源;
		this.技能模板 = 技能模板;
		this.技能数据 = 技能数据;
		this.动作编号 = 动作编号;
		this.释放地图 = 释放地图;
		this.释放位置 = 释放位置;
		this.技能目标 = 技能目标;
		this.技能锚点 = 技能锚点;
		this.父类技能 = 父类技能;
		释放时间 = 主程.当前时间;
		this.目标借位 = 目标借位;
		this.命中列表 = 命中列表 ?? new Dictionary<int, 命中详情>();
		节点列表 = new SortedDictionary<int, 技能任务>(技能模板.节点列表);
		if (节点列表.Count != 0)
		{
			this.技能来源.技能任务.Add(this);
			预约时间 = 释放时间.AddMilliseconds(飞行耗时 + 节点列表.First().Key);
		}
	}

	public void 处理任务()
	{
		if ((预约时间 - 处理计时).TotalMilliseconds > 5.0 && 主程.当前时间 < 预约时间)
		{
			return;
		}
		KeyValuePair<int, 技能任务> keyValuePair = 节点列表.First();
		节点列表.Remove(keyValuePair.Key);
		技能任务 value = keyValuePair.Value;
		处理计时 = 预约时间;
		if (value != null)
		{
			if (value is A_00_触发子类技能 a_00_触发子类技能)
			{
				if (游戏技能.数据表.TryGetValue(a_00_触发子类技能.触发技能名字, out var value2))
				{
					bool flag = true;
					if (a_00_触发子类技能.计算触发概率)
					{
						flag = ((!a_00_触发子类技能.计算幸运概率) ? 计算类.计算概率(a_00_触发子类技能.技能触发概率 + ((a_00_触发子类技能.增加概率Buff == 0 || !技能来源.Buff列表.ContainsKey(a_00_触发子类技能.增加概率Buff)) ? 0f : a_00_触发子类技能.Buff增加系数)) : 计算类.计算概率(计算类.计算幸运(技能来源[游戏对象属性.幸运等级])));
					}
					if (flag && a_00_触发子类技能.验证自身Buff)
					{
						if (技能来源.Buff列表.ContainsKey(a_00_触发子类技能.自身Buff编号))
						{
							if (a_00_触发子类技能.触发成功移除)
							{
								技能来源.移除Buff时处理(a_00_触发子类技能.自身Buff编号);
							}
						}
						else
						{
							flag = false;
						}
					}
					if (flag && a_00_触发子类技能.验证铭文技能 && 技能来源 is 玩家实例 玩家实例)
					{
						int num = (int)a_00_触发子类技能.所需铭文编号 / 10;
						int num2 = (int)a_00_触发子类技能.所需铭文编号 % 10;
						flag = 玩家实例.主体技能表.TryGetValue((ushort)num, out var v) && (a_00_触发子类技能.同组铭文无效 ? (num2 == v.铭文编号) : (num2 == 0 || num2 == v.铭文编号));
					}
					if (flag)
					{
						switch (a_00_触发子类技能.技能触发方式)
						{
						case 技能触发方式.原点位置绝对触发:
							new 技能实例(技能来源, value2, 技能数据, 动作编号, 释放地图, 释放位置, 技能目标, 释放位置, this);
							break;
						case 技能触发方式.锚点位置绝对触发:
							new 技能实例(技能来源, value2, 技能数据, 动作编号, 释放地图, 释放位置, 技能目标, 技能锚点, this);
							break;
						case 技能触发方式.刺杀位置绝对触发:
							new 技能实例(技能来源, value2, 技能数据, 动作编号, 释放地图, 释放位置, 技能目标, 计算类.前方坐标(释放位置, 技能锚点, 2), this);
							break;
						case 技能触发方式.目标命中绝对触发:
							foreach (KeyValuePair<int, 命中详情> item in 命中列表)
							{
								if ((item.Value.技能反馈 & 技能命中反馈.闪避) == 0 && (item.Value.技能反馈 & 技能命中反馈.丢失) == 0)
								{
									new 技能实例(技能来源, value2, 技能数据, 动作编号, 释放地图, (父类技能 == null) ? 释放位置 : 技能锚点, item.Value.技能目标, item.Value.技能目标.当前坐标, this);
								}
							}
							break;
						case 技能触发方式.怪物死亡绝对触发:
							foreach (KeyValuePair<int, 命中详情> item2 in 命中列表)
							{
								if (item2.Value.技能目标 is 怪物实例 && (item2.Value.技能反馈 & 技能命中反馈.死亡) != 0)
								{
									new 技能实例(技能来源, value2, 技能数据, 动作编号, 释放地图, 释放位置, null, item2.Value.技能目标.当前坐标, this);
								}
							}
							break;
						case 技能触发方式.怪物死亡换位触发:
							foreach (KeyValuePair<int, 命中详情> item3 in 命中列表)
							{
								if (item3.Value.技能目标 is 怪物实例 && (item3.Value.技能反馈 & 技能命中反馈.死亡) != 0)
								{
									new 技能实例(技能来源, value2, null, item3.Value.技能目标.动作编号++, 释放地图, item3.Value.技能目标.当前坐标, item3.Value.技能目标, item3.Value.技能目标.当前坐标, this, null, 目标借位: true);
								}
							}
							break;
						case 技能触发方式.怪物命中绝对触发:
							foreach (KeyValuePair<int, 命中详情> item4 in 命中列表)
							{
								if (item4.Value.技能目标 is 怪物实例 && (item4.Value.技能反馈 & 技能命中反馈.丢失) == 0)
								{
									new 技能实例(技能来源, value2, 技能数据, 动作编号, 释放地图, (父类技能 == null) ? 释放位置 : 技能锚点, item4.Value.技能目标, item4.Value.技能目标.当前坐标, this);
								}
							}
							break;
						case 技能触发方式.无目标锚点位触发:
							if (命中列表.Count == 0 || 命中列表.Values.FirstOrDefault((命中详情 O) => O.技能反馈 != 技能命中反馈.丢失) == null)
							{
								new 技能实例(技能来源, value2, 技能数据, 动作编号, 释放地图, 释放位置, null, 技能锚点, this);
							}
							break;
						case 技能触发方式.目标位置绝对触发:
							foreach (KeyValuePair<int, 命中详情> item5 in 命中列表)
							{
								new 技能实例(技能来源, value2, 技能数据, 动作编号, 释放地图, 释放位置, item5.Value.技能目标, item5.Value.技能目标.当前坐标, this);
							}
							break;
						case 技能触发方式.正手反手随机触发:
						{
							if (!计算类.计算概率(0.5f) || !游戏技能.数据表.TryGetValue(a_00_触发子类技能.反手技能名字, out var value3))
							{
								new 技能实例(技能来源, value2, 技能数据, 动作编号, 释放地图, 释放位置, null, 技能锚点, this);
							}
							else
							{
								new 技能实例(技能来源, value3, 技能数据, 动作编号, 释放地图, 释放位置, null, 技能锚点, this);
							}
							break;
						}
						case 技能触发方式.目标死亡绝对触发:
							foreach (KeyValuePair<int, 命中详情> item6 in 命中列表)
							{
								if ((item6.Value.技能反馈 & 技能命中反馈.死亡) != 0)
								{
									new 技能实例(技能来源, value2, 技能数据, 动作编号, 释放地图, 释放位置, null, item6.Value.技能目标.当前坐标, this);
								}
							}
							break;
						case 技能触发方式.目标闪避绝对触发:
							foreach (KeyValuePair<int, 命中详情> item7 in 命中列表)
							{
								if ((item7.Value.技能反馈 & 技能命中反馈.闪避) != 0)
								{
									new 技能实例(技能来源, value2, 技能数据, 动作编号, 释放地图, 释放位置, null, item7.Value.技能目标.当前坐标, this);
								}
							}
							break;
						}
					}
				}
			}
			else
			{
				A_01_触发对象Buff 触发Buff = value as A_01_触发对象Buff;
				if (触发Buff == null)
				{
					if (value is A_02_触发陷阱技能 a_02_触发陷阱技能)
					{
						if (技能陷阱.数据表.TryGetValue(a_02_触发陷阱技能.触发陷阱技能, out var 陷阱模板))
						{
							int num3 = 0;
							Point[] array = 计算类.技能范围(技能锚点, 计算类.计算方向(释放位置, 技能锚点), a_02_触发陷阱技能.触发陷阱数量);
							foreach (Point 坐标 in array)
							{
								if (!释放地图.地形阻塞(坐标) && (陷阱模板.陷阱允许叠加 || 释放地图[坐标].FirstOrDefault((地图对象 O) => O is 陷阱实例 陷阱实例2 && 陷阱实例2.陷阱分组编号 != 0 && 陷阱实例2.陷阱分组编号 == 陷阱模板.分组编号) == null))
								{
									技能来源.陷阱列表.Add(new 陷阱实例(技能来源, 陷阱模板, 释放地图, 坐标));
									num3++;
								}
							}
							if (num3 != 0 && a_02_触发陷阱技能.经验技能编号 != 0 && 技能来源 is 玩家实例 玩家实例2)
							{
								玩家实例2.技能增加经验(a_02_触发陷阱技能.经验技能编号);
							}
						}
					}
					else if (value is B_00_技能切换通知 b_00_技能切换通知)
					{
						if (!技能来源.Buff列表.ContainsKey(b_00_技能切换通知.技能标记编号))
						{
							if (游戏Buff.数据表.ContainsKey(b_00_技能切换通知.技能标记编号))
							{
								技能来源.添加Buff时处理(b_00_技能切换通知.技能标记编号, 技能来源);
							}
						}
						else if (b_00_技能切换通知.允许移除标记)
						{
							技能来源.移除Buff时处理(b_00_技能切换通知.技能标记编号);
						}
					}
					else if (value is B_01_技能释放通知 b_01_技能释放通知)
					{
						if (b_01_技能释放通知.调整角色朝向)
						{
							游戏方向 游戏方向 = 计算类.计算方向(释放位置, 技能锚点);
							if (游戏方向 == 技能来源.当前方向)
							{
								技能来源.发送封包(new 对象转动方向
								{
									对象编号 = 技能来源.地图编号,
									对象朝向 = (ushort)游戏方向,
									转向耗时 = ((!(技能来源 is 玩家实例)) ? ((ushort)1) : ((ushort)0))
								});
							}
							else
							{
								技能来源.当前方向 = 计算类.计算方向(释放位置, 技能锚点);
							}
						}
						if (b_01_技能释放通知.移除技能标记 && 技能模板.技能标记编号 != 0)
						{
							技能来源.移除Buff时处理(技能模板.技能标记编号);
						}
						if (b_01_技能释放通知.自身冷却时间 != 0 || b_01_技能释放通知.Buff增加冷却)
						{
							if (检查计数 && 技能来源 is 玩家实例 玩家实例3)
							{
								if (--技能数据.剩余次数.V <= 0)
								{
									技能来源.冷却记录[技能编号 | 0x1000000] = 释放时间.AddMilliseconds((技能数据.计数时间 - 主程.当前时间).TotalMilliseconds);
								}
								玩家实例3.网络连接.发送封包(new 同步技能计数
								{
									技能编号 = 技能数据.技能编号.V,
									技能计数 = 技能数据.剩余次数.V,
									技能冷却 = (int)(技能数据.计数时间 - 主程.当前时间).TotalMilliseconds
								});
							}
							else if (b_01_技能释放通知.自身冷却时间 > 0 || b_01_技能释放通知.Buff增加冷却)
							{
								int num4 = b_01_技能释放通知.自身冷却时间;
								if (b_01_技能释放通知.Buff增加冷却 && 技能来源.Buff列表.ContainsKey(b_01_技能释放通知.增加冷却Buff))
								{
									num4 += b_01_技能释放通知.冷却增加时间;
								}
								DateTime dateTime = 释放时间.AddMilliseconds(num4);
								DateTime dateTime2 = (技能来源.冷却记录.ContainsKey(技能编号 | 0x1000000) ? 技能来源.冷却记录[技能编号 | 0x1000000] : default(DateTime));
								if (num4 > 0 && dateTime > dateTime2)
								{
									技能来源.冷却记录[技能编号 | 0x1000000] = dateTime;
									技能来源.发送封包(new 添加技能冷却
									{
										冷却编号 = (技能编号 | 0x1000000),
										冷却时间 = num4
									});
								}
							}
						}
						if (技能来源 is 玩家实例 玩家实例4 && b_01_技能释放通知.分组冷却时间 != 0 && 分组编号 != 0)
						{
							DateTime dateTime3 = 释放时间.AddMilliseconds(b_01_技能释放通知.分组冷却时间);
							DateTime dateTime4 = (玩家实例4.冷却记录.ContainsKey(分组编号 | 0) ? 玩家实例4.冷却记录[分组编号 | 0] : default(DateTime));
							if (dateTime3 > dateTime4)
							{
								玩家实例4.冷却记录[分组编号 | 0] = dateTime3;
							}
							技能来源.发送封包(new 添加技能冷却
							{
								冷却编号 = (分组编号 | 0),
								冷却时间 = b_01_技能释放通知.分组冷却时间
							});
						}
						if (b_01_技能释放通知.角色忙绿时间 != 0)
						{
							技能来源.忙碌时间 = 释放时间.AddMilliseconds(b_01_技能释放通知.角色忙绿时间);
						}
						if (b_01_技能释放通知.发送释放通知)
						{
							地图对象 地图对象 = 技能来源;
							开始释放技能 开始释放技能 = new 开始释放技能
							{
								对象编号 = ((!目标借位 || 技能目标 == null) ? 技能来源.地图编号 : 技能目标.地图编号),
								技能编号 = 技能编号,
								技能等级 = 技能等级,
								技能铭文 = 铭文编号,
								锚点坐标 = 技能锚点,
								动作编号 = 动作编号
							};
							开始释放技能.目标编号 = 技能目标?.地图编号 ?? 0;
							开始释放技能.锚点高度 = 释放地图.地形高度(技能锚点);
							地图对象.发送封包(开始释放技能);
						}
					}
					else if (value is B_02_技能命中通知 b_02_技能命中通知)
					{
						if (!b_02_技能命中通知.命中扩展通知)
						{
							技能来源.发送封包(new 触发技能正常
							{
								对象编号 = ((!目标借位 || 技能目标 == null) ? 技能来源.地图编号 : 技能目标.地图编号),
								技能编号 = 技能编号,
								技能等级 = 技能等级,
								技能铭文 = 铭文编号,
								动作编号 = 动作编号,
								命中描述 = 命中详情.命中描述(命中列表, 飞行耗时)
							});
						}
						else
						{
							技能来源.发送封包(new 触发技能扩展
							{
								对象编号 = ((!目标借位 || 技能目标 == null) ? 技能来源.地图编号 : 技能目标.地图编号),
								技能编号 = 技能编号,
								技能等级 = 技能等级,
								技能铭文 = 铭文编号,
								动作编号 = 动作编号,
								命中描述 = 命中详情.命中描述(命中列表, 飞行耗时)
							});
						}
						if (b_02_技能命中通知.计算飞行耗时)
						{
							飞行耗时 = 计算类.网格距离(释放位置, 技能锚点) * b_02_技能命中通知.单格飞行耗时;
						}
					}
					else if (!(value is B_03_前摇结束通知 b_03_前摇结束通知))
					{
						if (value is B_04_后摇结束通知 b_04_后摇结束通知)
						{
							技能来源.发送封包(new 技能释放完成
							{
								技能编号 = 技能编号,
								动作编号 = 动作编号
							});
							if (b_04_后摇结束通知.后摇结束死亡)
							{
								技能来源.自身死亡处理(null, 技能击杀: false);
							}
						}
						else if (!(value is C_00_计算技能锚点 c_00_计算技能锚点))
						{
							if (!(value is C_01_计算命中目标 c_01_计算命中目标))
							{
								if (value is C_02_计算目标伤害 c_02_计算目标伤害)
								{
									float num5 = 1f;
									foreach (KeyValuePair<int, 命中详情> item8 in 命中列表)
									{
										if (!c_02_计算目标伤害.点爆命中目标 || !item8.Value.技能目标.Buff列表.ContainsKey(c_02_计算目标伤害.点爆标记编号))
										{
											if (c_02_计算目标伤害.点爆命中目标 && c_02_计算目标伤害.失败添加层数)
											{
												item8.Value.技能目标.添加Buff时处理(c_02_计算目标伤害.点爆标记编号, 技能来源);
												continue;
											}
										}
										else
										{
											item8.Value.技能目标.移除Buff时处理(c_02_计算目标伤害.点爆标记编号);
										}
										item8.Value.技能目标.被动受伤时处理(this, c_02_计算目标伤害, item8.Value, num5);
										if ((item8.Value.技能反馈 & 技能命中反馈.丢失) == 0)
										{
											if (c_02_计算目标伤害.数量衰减伤害)
											{
												num5 = Math.Max(c_02_计算目标伤害.伤害衰减下限, num5 - c_02_计算目标伤害.伤害衰减系数);
											}
											技能来源.发送封包(new 触发命中特效
											{
												对象编号 = ((!目标借位 || 技能目标 == null) ? 技能来源.地图编号 : 技能目标.地图编号),
												技能编号 = 技能编号,
												技能等级 = 技能等级,
												技能铭文 = 铭文编号,
												动作编号 = 动作编号,
												目标编号 = item8.Value.技能目标.地图编号,
												技能反馈 = (ushort)item8.Value.技能反馈,
												技能伤害 = -item8.Value.技能伤害,
												招架伤害 = item8.Value.招架伤害
											});
										}
									}
									if (c_02_计算目标伤害.目标死亡回复)
									{
										foreach (KeyValuePair<int, 命中详情> item9 in 命中列表)
										{
											if ((item9.Value.技能反馈 & 技能命中反馈.死亡) != 0 && item9.Value.技能目标.特定类型(技能来源, c_02_计算目标伤害.回复限定类型))
											{
												int num6 = c_02_计算目标伤害.体力回复基数;
												if (c_02_计算目标伤害.等级差减回复)
												{
													int 数值 = 技能来源.当前等级 - item9.Value.技能目标.当前等级 - c_02_计算目标伤害.减回复等级差;
													int num7 = c_02_计算目标伤害.零回复等级差 - c_02_计算目标伤害.减回复等级差;
													float num8 = (float)计算类.数值限制(0, 数值, num7) / (float)num7;
													num6 = (int)((float)num6 - (float)num6 * num8);
												}
												if (num6 > 0)
												{
													技能来源.当前体力 += num6;
													技能来源.发送封包(new 体力变动飘字
													{
														血量变化 = num6,
														对象编号 = 技能来源.地图编号
													});
												}
											}
										}
									}
									if (c_02_计算目标伤害.击杀减少冷却)
									{
										int num9 = 0;
										foreach (KeyValuePair<int, 命中详情> item10 in 命中列表)
										{
											if ((item10.Value.技能反馈 & 技能命中反馈.死亡) != 0 && item10.Value.技能目标.特定类型(技能来源, c_02_计算目标伤害.冷却减少类型))
											{
												num9 += c_02_计算目标伤害.冷却减少时间;
											}
										}
										if (num9 > 0)
										{
											if (技能来源.冷却记录.TryGetValue(c_02_计算目标伤害.冷却减少技能 | 0x1000000, out var v2))
											{
												v2 -= TimeSpan.FromMilliseconds(num9);
												技能来源.冷却记录[c_02_计算目标伤害.冷却减少技能 | 0x1000000] = v2;
												技能来源.发送封包(new 添加技能冷却
												{
													冷却编号 = (c_02_计算目标伤害.冷却减少技能 | 0x1000000),
													冷却时间 = Math.Max(0, (int)(v2 - 主程.当前时间).TotalMilliseconds)
												});
											}
											if (c_02_计算目标伤害.冷却减少分组 != 0 && 技能来源 is 玩家实例 玩家实例5 && 玩家实例5.冷却记录.TryGetValue(c_02_计算目标伤害.冷却减少分组 | 0, out var v3))
											{
												v3 -= TimeSpan.FromMilliseconds(num9);
												玩家实例5.冷却记录[c_02_计算目标伤害.冷却减少分组 | 0] = v3;
												技能来源.发送封包(new 添加技能冷却
												{
													冷却编号 = (c_02_计算目标伤害.冷却减少分组 | 0),
													冷却时间 = Math.Max(0, (int)(v3 - 主程.当前时间).TotalMilliseconds)
												});
											}
										}
									}
									if (c_02_计算目标伤害.命中减少冷却)
									{
										int num10 = 0;
										foreach (KeyValuePair<int, 命中详情> item11 in 命中列表)
										{
											if ((item11.Value.技能反馈 & 技能命中反馈.闪避) == 0 && (item11.Value.技能反馈 & 技能命中反馈.丢失) == 0 && item11.Value.技能目标.特定类型(技能来源, c_02_计算目标伤害.冷却减少类型))
											{
												num10 += c_02_计算目标伤害.冷却减少时间;
											}
										}
										if (num10 > 0)
										{
											if (技能来源.冷却记录.TryGetValue(c_02_计算目标伤害.冷却减少技能 | 0x1000000, out var v4))
											{
												v4 -= TimeSpan.FromMilliseconds(num10);
												技能来源.冷却记录[c_02_计算目标伤害.冷却减少技能 | 0x1000000] = v4;
												技能来源.发送封包(new 添加技能冷却
												{
													冷却编号 = (c_02_计算目标伤害.冷却减少技能 | 0x1000000),
													冷却时间 = Math.Max(0, (int)(v4 - 主程.当前时间).TotalMilliseconds)
												});
											}
											if (c_02_计算目标伤害.冷却减少分组 != 0 && 技能来源 is 玩家实例 玩家实例6 && 玩家实例6.冷却记录.TryGetValue(c_02_计算目标伤害.冷却减少分组 | 0, out var v5))
											{
												v5 -= TimeSpan.FromMilliseconds(num10);
												玩家实例6.冷却记录[c_02_计算目标伤害.冷却减少分组 | 0] = v5;
												技能来源.发送封包(new 添加技能冷却
												{
													冷却编号 = (c_02_计算目标伤害.冷却减少分组 | 0),
													冷却时间 = Math.Max(0, (int)(v5 - 主程.当前时间).TotalMilliseconds)
												});
											}
										}
									}
									if (c_02_计算目标伤害.目标硬直时间 > 0)
									{
										foreach (KeyValuePair<int, 命中详情> item12 in 命中列表)
										{
											if ((item12.Value.技能反馈 & 技能命中反馈.闪避) == 0 && (item12.Value.技能反馈 & 技能命中反馈.丢失) == 0 && item12.Value.技能目标 is 怪物实例 怪物实例 && 怪物实例.怪物级别 != 怪物级别分类.头目首领)
											{
												item12.Value.技能目标.硬直时间 = 主程.当前时间.AddMilliseconds(c_02_计算目标伤害.目标硬直时间);
											}
										}
									}
									if (c_02_计算目标伤害.清除目标状态 && c_02_计算目标伤害.清除状态列表.Count != 0)
									{
										foreach (KeyValuePair<int, 命中详情> item13 in 命中列表)
										{
											if ((item13.Value.技能反馈 & 技能命中反馈.闪避) != 0 || (item13.Value.技能反馈 & 技能命中反馈.丢失) != 0)
											{
												continue;
											}
											foreach (ushort item14 in c_02_计算目标伤害.清除状态列表)
											{
												item13.Value.技能目标.移除Buff时处理(item14);
											}
										}
									}
									if (c_02_计算目标伤害.增加技能经验 && 命中列表.Count != 0)
									{
										(技能来源 as 玩家实例).技能增加经验(c_02_计算目标伤害.经验技能编号);
									}
									if (c_02_计算目标伤害.扣除武器持久 && 命中列表.Count != 0)
									{
										(技能来源 as 玩家实例).武器损失持久();
									}
								}
								else if (!(value is C_03_计算对象位移 c_03_计算对象位移))
								{
									if (!(value is C_04_计算目标诱惑 参数))
									{
										if (!(value is C_06_计算宠物召唤 c_06_计算宠物召唤))
										{
											if (value is C_05_计算目标回复 c_05_计算目标回复)
											{
												foreach (KeyValuePair<int, 命中详情> item15 in 命中列表)
												{
													item15.Value.技能目标.被动回复时处理(this, c_05_计算目标回复);
												}
												if (c_05_计算目标回复.增加技能经验 && 命中列表.Count != 0)
												{
													(技能来源 as 玩家实例).技能增加经验(c_05_计算目标回复.经验技能编号);
												}
											}
											else if (value is C_07_计算目标瞬移 参数2)
											{
												(技能来源 as 玩家实例).玩家瞬间移动(this, 参数2);
											}
										}
										else if (c_06_计算宠物召唤.怪物召唤同伴)
										{
											if (c_06_计算宠物召唤.召唤宠物名字 == null || c_06_计算宠物召唤.召唤宠物名字.Length == 0)
											{
												return;
											}
											if (游戏怪物.数据表.TryGetValue(c_06_计算宠物召唤.召唤宠物名字, out var value4))
											{
												new 怪物实例(value4, 释放地图, int.MaxValue, new Point[1] { 释放位置 }, 禁止复活: true, 立即刷新: true).存活时间 = 主程.当前时间.AddMinutes(1.0);
											}
										}
										else if (技能来源 is 玩家实例 玩家实例7)
										{
											if ((c_06_计算宠物召唤.检查技能铭文 && (!玩家实例7.主体技能表.TryGetValue(技能编号, out var v6) || v6.铭文编号 != 铭文编号)) || c_06_计算宠物召唤.召唤宠物名字 == null || c_06_计算宠物召唤.召唤宠物名字.Length == 0)
											{
												return;
											}
											int num11 = ((c_06_计算宠物召唤.召唤宠物数量?.Length > 技能等级) ? c_06_计算宠物召唤.召唤宠物数量[技能等级] : 0);
											if (玩家实例7.宠物列表.Count < num11 && 游戏怪物.数据表.TryGetValue(c_06_计算宠物召唤.召唤宠物名字, out var value5))
											{
												byte 等级上限 = (byte)((c_06_计算宠物召唤.宠物等级上限?.Length > 技能等级) ? c_06_计算宠物召唤.宠物等级上限[技能等级] : 0);
												宠物实例 宠物实例 = new 宠物实例(玩家实例7, value5, 技能等级, 等级上限, c_06_计算宠物召唤.宠物绑定武器);
												玩家实例7.网络连接.发送封包(new 同步宠物等级
												{
													宠物编号 = 宠物实例.地图编号,
													宠物等级 = 宠物实例.宠物等级
												});
												玩家实例7.网络连接.发送封包(new 游戏错误提示
												{
													错误代码 = 9473,
													第一参数 = (int)玩家实例7.宠物模式
												});
												玩家实例7.宠物数据.Add(宠物实例.宠物数据);
												玩家实例7.宠物列表.Add(宠物实例);
												if (c_06_计算宠物召唤.增加技能经验)
												{
													玩家实例7.技能增加经验(c_06_计算宠物召唤.经验技能编号);
												}
											}
										}
									}
									else
									{
										foreach (KeyValuePair<int, 命中详情> item16 in 命中列表)
										{
											(技能来源 as 玩家实例).玩家诱惑目标(this, 参数, item16.Value.技能目标);
										}
									}
								}
								else
								{
									byte[] 自身位移次数 = c_03_计算对象位移.自身位移次数;
									byte b = (byte)((((自身位移次数 != null) ? 自身位移次数.Length : 0) > 技能等级) ? c_03_计算对象位移.自身位移次数[技能等级] : 0);
									if (c_03_计算对象位移.角色自身位移 && (释放地图 != 技能来源.当前地图 || 分段编号 >= b))
									{
										技能来源.发送封包(new 技能释放中断
										{
											对象编号 = ((!目标借位 || 技能目标 == null) ? 技能来源.地图编号 : 技能目标.地图编号),
											技能编号 = 技能编号,
											技能等级 = 技能等级,
											技能铭文 = 铭文编号,
											动作编号 = 动作编号,
											技能分段 = 分段编号
										});
										技能来源.发送封包(new 技能释放完成
										{
											技能编号 = 技能编号,
											动作编号 = 动作编号
										});
									}
									else if (c_03_计算对象位移.角色自身位移)
									{
										int 数量 = (c_03_计算对象位移.推动目标位移 ? c_03_计算对象位移.连续推动数量 : 0);
										byte[] 自身位移距离 = c_03_计算对象位移.自身位移距离;
										int num12 = ((((自身位移距离 != null) ? 自身位移距离.Length : 0) > 技能等级) ? c_03_计算对象位移.自身位移距离[技能等级] : 0);
										int num13 = ((c_03_计算对象位移.允许超出锚点 || c_03_计算对象位移.锚点反向位移) ? num12 : Math.Min(num12, 计算类.网格距离(释放位置, 技能锚点)));
										Point 锚点 = ((!c_03_计算对象位移.锚点反向位移) ? 技能锚点 : 计算类.前方坐标(技能来源.当前坐标, 计算类.计算方向(技能锚点, 技能来源.当前坐标), num13));
										if (!技能来源.能否位移(技能来源, 锚点, num13, 数量, c_03_计算对象位移.能否穿越障碍, out var 终点, out var 目标))
										{
											if (计算类.计算概率(c_03_计算对象位移.失败Buff概率))
											{
												技能来源.添加Buff时处理(c_03_计算对象位移.失败Buff编号, 技能来源);
											}
											技能来源.硬直时间 = 主程.当前时间.AddMilliseconds((int)c_03_计算对象位移.自身硬直时间);
											分段编号 = b;
										}
										else
										{
											地图对象[] array2 = 目标;
											foreach (地图对象 地图对象2 in array2)
											{
												if (c_03_计算对象位移.目标位移编号 != 0 && 计算类.计算概率(c_03_计算对象位移.位移Buff概率))
												{
													地图对象2.添加Buff时处理(c_03_计算对象位移.目标位移编号, 技能来源);
												}
												if (c_03_计算对象位移.目标附加编号 != 0 && 计算类.计算概率(c_03_计算对象位移.附加Buff概率) && 地图对象2.特定类型(技能来源, c_03_计算对象位移.限定附加类型))
												{
													地图对象2.添加Buff时处理(c_03_计算对象位移.目标附加编号, 技能来源);
												}
												地图对象2.当前方向 = 计算类.计算方向(地图对象2.当前坐标, 技能来源.当前坐标);
												Point point = 计算类.前方坐标(地图对象2.当前坐标, 计算类.计算方向(技能来源.当前坐标, 地图对象2.当前坐标), 1);
												地图对象2.忙碌时间 = 主程.当前时间.AddMilliseconds(c_03_计算对象位移.目标位移耗时 * 60);
												地图对象2.硬直时间 = 主程.当前时间.AddMilliseconds(c_03_计算对象位移.目标位移耗时 * 60 + c_03_计算对象位移.目标硬直时间);
												地图对象2.发送封包(new 对象被动位移
												{
													位移坐标 = point,
													对象编号 = 地图对象2.地图编号,
													位移朝向 = (ushort)地图对象2.当前方向,
													位移速度 = c_03_计算对象位移.目标位移耗时
												});
												地图对象2.自身移动时处理(point);
												if (c_03_计算对象位移.推动增加经验 && !经验增加)
												{
													(技能来源 as 玩家实例).技能增加经验(技能编号);
													经验增加 = true;
												}
											}
											if (c_03_计算对象位移.成功Buff编号 != 0 && 计算类.计算概率(c_03_计算对象位移.成功Buff概率))
											{
												技能来源.添加Buff时处理(c_03_计算对象位移.成功Buff编号, 技能来源);
											}
											技能来源.当前方向 = 计算类.计算方向(技能来源.当前坐标, 终点);
											int num14 = c_03_计算对象位移.自身位移耗时 * 技能来源.网格距离(终点);
											技能来源.忙碌时间 = 主程.当前时间.AddMilliseconds(num14 * 60);
											技能来源.发送封包(new 对象被动位移
											{
												位移坐标 = 终点,
												对象编号 = 技能来源.地图编号,
												位移朝向 = (ushort)技能来源.当前方向,
												位移速度 = (ushort)num14
											});
											技能来源.自身移动时处理(终点);
											if (技能来源 is 玩家实例 玩家实例8 && c_03_计算对象位移.位移增加经验 && !经验增加)
											{
												玩家实例8.技能增加经验(技能编号);
												经验增加 = true;
											}
											if (c_03_计算对象位移.多段位移通知)
											{
												技能来源.发送封包(new 触发技能正常
												{
													对象编号 = ((!目标借位 || 技能目标 == null) ? 技能来源.地图编号 : 技能目标.地图编号),
													技能编号 = 技能编号,
													技能等级 = 技能等级,
													技能铭文 = 铭文编号,
													动作编号 = 动作编号,
													技能分段 = 分段编号
												});
											}
											if (b > 1)
											{
												技能锚点 = 计算类.前方坐标(技能来源.当前坐标, 技能来源.当前方向, num13);
											}
											分段编号++;
										}
										if (b > 1)
										{
											int j;
											for (j = keyValuePair.Key + c_03_计算对象位移.自身位移耗时 * 60; 节点列表.ContainsKey(j); j++)
											{
											}
											节点列表.Add(j, keyValuePair.Value);
										}
									}
									else if (c_03_计算对象位移.推动目标位移)
									{
										foreach (KeyValuePair<int, 命中详情> item17 in 命中列表)
										{
											if ((item17.Value.技能反馈 & 技能命中反馈.闪避) != 0 || (item17.Value.技能反馈 & 技能命中反馈.丢失) != 0 || (item17.Value.技能反馈 & 技能命中反馈.死亡) != 0 || !计算类.计算概率(c_03_计算对象位移.推动目标概率) || !item17.Value.技能目标.特定类型(技能来源, c_03_计算对象位移.推动目标类型))
											{
												continue;
											}
											byte[] 目标位移距离 = c_03_计算对象位移.目标位移距离;
											int val = ((((目标位移距离 != null) ? 目标位移距离.Length : 0) > 技能等级) ? c_03_计算对象位移.目标位移距离[技能等级] : 0);
											int num15 = 计算类.网格距离(技能来源.当前坐标, item17.Value.技能目标.当前坐标);
											int num16 = Math.Max(0, Math.Min(8 - num15, val));
											if (num16 == 0)
											{
												continue;
											}
											游戏方向 方向 = 计算类.计算方向(技能来源.当前坐标, item17.Value.技能目标.当前坐标);
											Point 锚点2 = 计算类.前方坐标(item17.Value.技能目标.当前坐标, 方向, num16);
											if (item17.Value.技能目标.能否位移(技能来源, 锚点2, num16, 0, 穿墙: false, out var 终点2, out var _))
											{
												if (计算类.计算概率(c_03_计算对象位移.位移Buff概率))
												{
													item17.Value.技能目标.添加Buff时处理(c_03_计算对象位移.目标位移编号, 技能来源);
												}
												if (计算类.计算概率(c_03_计算对象位移.附加Buff概率) && item17.Value.技能目标.特定类型(技能来源, c_03_计算对象位移.限定附加类型))
												{
													item17.Value.技能目标.添加Buff时处理(c_03_计算对象位移.目标附加编号, 技能来源);
												}
												item17.Value.技能目标.当前方向 = 计算类.计算方向(item17.Value.技能目标.当前坐标, 技能来源.当前坐标);
												ushort num17 = (ushort)(计算类.网格距离(item17.Value.技能目标.当前坐标, 终点2) * c_03_计算对象位移.目标位移耗时);
												item17.Value.技能目标.忙碌时间 = 主程.当前时间.AddMilliseconds(num17 * 60);
												item17.Value.技能目标.硬直时间 = 主程.当前时间.AddMilliseconds(num17 * 60 + c_03_计算对象位移.目标硬直时间);
												item17.Value.技能目标.发送封包(new 对象被动位移
												{
													位移坐标 = 终点2,
													位移速度 = num17,
													对象编号 = item17.Value.技能目标.地图编号,
													位移朝向 = (ushort)item17.Value.技能目标.当前方向
												});
												item17.Value.技能目标.自身移动时处理(终点2);
												if (c_03_计算对象位移.推动增加经验 && !经验增加)
												{
													(技能来源 as 玩家实例).技能增加经验(技能编号);
													经验增加 = true;
												}
											}
										}
									}
								}
							}
							else
							{
								if (c_01_计算命中目标.清空命中列表)
								{
									命中列表 = new Dictionary<int, 命中详情>();
								}
								if (c_01_计算命中目标.技能能否穿墙 || !释放地图.地形遮挡(释放位置, 技能锚点))
								{
									switch (c_01_计算命中目标.技能锁定方式)
									{
									case 技能锁定类型.锁定自身:
										技能来源.被技能命中处理(this, c_01_计算命中目标);
										break;
									case 技能锁定类型.锁定目标:
										技能目标?.被技能命中处理(this, c_01_计算命中目标);
										break;
									case 技能锁定类型.锁定自身坐标:
									{
										Point[] array = 计算类.技能范围(技能来源.当前坐标, 计算类.计算方向(释放位置, 技能锚点), c_01_计算命中目标.技能范围类型);
										foreach (Point 坐标4 in array)
										{
											foreach (地图对象 item18 in 释放地图[坐标4])
											{
												item18.被技能命中处理(this, c_01_计算命中目标);
											}
										}
										break;
									}
									case 技能锁定类型.锁定目标坐标:
									{
										Point[] array = 计算类.技能范围(技能目标?.当前坐标 ?? 技能锚点, 计算类.计算方向(释放位置, 技能锚点), c_01_计算命中目标.技能范围类型);
										foreach (Point 坐标3 in array)
										{
											foreach (地图对象 item19 in 释放地图[坐标3])
											{
												item19.被技能命中处理(this, c_01_计算命中目标);
											}
										}
										break;
									}
									case 技能锁定类型.锁定锚点坐标:
									{
										Point[] array = 计算类.技能范围(技能锚点, 计算类.计算方向(释放位置, 技能锚点), c_01_计算命中目标.技能范围类型);
										foreach (Point 坐标5 in array)
										{
											foreach (地图对象 item20 in 释放地图[坐标5])
											{
												item20.被技能命中处理(this, c_01_计算命中目标);
											}
										}
										break;
									}
									case 技能锁定类型.放空锁定自身:
									{
										Point[] array = 计算类.技能范围(技能锚点, 计算类.计算方向(释放位置, 技能锚点), c_01_计算命中目标.技能范围类型);
										foreach (Point 坐标2 in array)
										{
											foreach (地图对象 item21 in 释放地图[坐标2])
											{
												item21.被技能命中处理(this, c_01_计算命中目标);
											}
										}
										if (命中列表.Count == 0)
										{
											技能来源.被技能命中处理(this, c_01_计算命中目标);
										}
										break;
									}
									}
								}
								if (命中列表.Count == 0 && c_01_计算命中目标.放空结束技能)
								{
									if (c_01_计算命中目标.发送中断通知)
									{
										技能来源.发送封包(new 技能释放中断
										{
											对象编号 = 技能来源.地图编号,
											技能编号 = 技能编号,
											技能等级 = 技能等级,
											技能铭文 = 铭文编号,
											动作编号 = 动作编号,
											技能分段 = 分段编号
										});
									}
									技能来源.技能任务.Remove(this);
									return;
								}
								if (c_01_计算命中目标.补发释放通知)
								{
									地图对象 地图对象3 = 技能来源;
									开始释放技能 开始释放技能2 = new 开始释放技能
									{
										对象编号 = ((!目标借位 || 技能目标 == null) ? 技能来源.地图编号 : 技能目标.地图编号),
										技能编号 = 技能编号,
										技能等级 = 技能等级,
										技能铭文 = 铭文编号
									};
									开始释放技能2.目标编号 = 技能目标?.地图编号 ?? 0;
									开始释放技能2.锚点坐标 = 技能锚点;
									开始释放技能2.锚点高度 = 释放地图.地形高度(技能锚点);
									开始释放技能2.动作编号 = 动作编号;
									地图对象3.发送封包(开始释放技能2);
								}
								if (命中列表.Count != 0 && c_01_计算命中目标.攻速提升类型 != 0 && 技能目标.特定类型(技能来源, c_01_计算命中目标.攻速提升类型))
								{
									攻速缩减 = 计算类.数值限制(计算类.计算攻速(-5), 攻速缩减 + 计算类.计算攻速(c_01_计算命中目标.攻速提升幅度), 计算类.计算攻速(5));
								}
								if (c_01_计算命中目标.清除目标状态 && c_01_计算命中目标.清除状态列表.Count != 0)
								{
									foreach (KeyValuePair<int, 命中详情> item22 in 命中列表)
									{
										if ((item22.Value.技能反馈 & 技能命中反馈.闪避) != 0 || (item22.Value.技能反馈 & 技能命中反馈.丢失) != 0)
										{
											continue;
										}
										foreach (ushort item23 in c_01_计算命中目标.清除状态列表.ToList())
										{
											item22.Value.技能目标.移除Buff时处理(item23);
										}
									}
								}
								if (c_01_计算命中目标.触发被动技能 && 命中列表.Count != 0 && 计算类.计算概率(c_01_计算命中目标.触发被动概率))
								{
									技能来源[游戏对象属性.技能标志] = 1;
								}
								if (c_01_计算命中目标.增加技能经验 && 命中列表.Count != 0)
								{
									(技能来源 as 玩家实例).技能增加经验(c_01_计算命中目标.经验技能编号);
								}
								if (c_01_计算命中目标.计算飞行耗时 && c_01_计算命中目标.单格飞行耗时 != 0)
								{
									飞行耗时 = 计算类.网格距离(释放位置, 技能锚点) * c_01_计算命中目标.单格飞行耗时;
								}
								if (c_01_计算命中目标.技能命中通知)
								{
									技能来源.发送封包(new 触发技能正常
									{
										对象编号 = ((!目标借位 || 技能目标 == null) ? 技能来源.地图编号 : 技能目标.地图编号),
										技能编号 = 技能编号,
										技能等级 = 技能等级,
										技能铭文 = 铭文编号,
										动作编号 = 动作编号,
										命中描述 = 命中详情.命中描述(命中列表, 飞行耗时)
									});
								}
								if (c_01_计算命中目标.技能扩展通知)
								{
									技能来源.发送封包(new 触发技能扩展
									{
										对象编号 = ((目标借位 && 技能目标 != null) ? 技能目标.地图编号 : 技能来源.地图编号),
										技能编号 = 技能编号,
										技能等级 = 技能等级,
										技能铭文 = 铭文编号,
										动作编号 = 动作编号,
										命中描述 = 命中详情.命中描述(命中列表, 飞行耗时)
									});
								}
							}
						}
						else if (c_00_计算技能锚点.计算当前位置)
						{
							技能目标 = null;
							if (!c_00_计算技能锚点.计算当前方向)
							{
								技能锚点 = 计算类.前方坐标(技能来源.当前坐标, 技能锚点, c_00_计算技能锚点.技能最近距离);
							}
							else
							{
								技能锚点 = 计算类.前方坐标(技能来源.当前坐标, 技能来源.当前方向, c_00_计算技能锚点.技能最近距离);
							}
						}
						else if (计算类.网格距离(释放位置, 技能锚点) > c_00_计算技能锚点.技能最远距离)
						{
							技能目标 = null;
							技能锚点 = 计算类.前方坐标(释放位置, 技能锚点, c_00_计算技能锚点.技能最远距离);
						}
						else if (计算类.网格距离(释放位置, 技能锚点) < c_00_计算技能锚点.技能最近距离)
						{
							技能目标 = null;
							if (!(释放位置 == 技能锚点))
							{
								技能锚点 = 计算类.前方坐标(释放位置, 技能锚点, c_00_计算技能锚点.技能最近距离);
							}
							else
							{
								技能锚点 = 计算类.前方坐标(释放位置, 技能来源.当前方向, c_00_计算技能锚点.技能最近距离);
							}
						}
					}
					else
					{
						if (b_03_前摇结束通知.计算攻速缩减)
						{
							攻速缩减 = 计算类.数值限制(计算类.计算攻速(-5), 攻速缩减 + 计算类.计算攻速(技能来源[游戏对象属性.攻击速度]), 计算类.计算攻速(5));
							if (攻速缩减 != 0)
							{
								foreach (KeyValuePair<int, 技能任务> item24 in 节点列表)
								{
									if (item24.Value is B_04_后摇结束通知)
									{
										int k;
										for (k = item24.Key - 攻速缩减; 节点列表.ContainsKey(k); k++)
										{
										}
										节点列表.Remove(item24.Key);
										节点列表.Add(k, item24.Value);
										break;
									}
								}
							}
						}
						if (b_03_前摇结束通知.禁止行走时间 != 0)
						{
							技能来源.行走时间 = 释放时间.AddMilliseconds(b_03_前摇结束通知.禁止行走时间);
						}
						if (b_03_前摇结束通知.禁止奔跑时间 != 0)
						{
							技能来源.奔跑时间 = 释放时间.AddMilliseconds(b_03_前摇结束通知.禁止奔跑时间);
						}
						if (b_03_前摇结束通知.角色硬直时间 != 0)
						{
							技能来源.硬直时间 = 释放时间.AddMilliseconds(b_03_前摇结束通知.计算攻速缩减 ? (b_03_前摇结束通知.角色硬直时间 - 攻速缩减) : b_03_前摇结束通知.角色硬直时间);
						}
						if (b_03_前摇结束通知.发送结束通知)
						{
							技能来源.发送封包(new 触发技能正常
							{
								对象编号 = ((目标借位 && 技能目标 != null) ? 技能目标.地图编号 : 技能来源.地图编号),
								技能编号 = 技能编号,
								技能等级 = 技能等级,
								技能铭文 = 铭文编号,
								动作编号 = 动作编号
							});
						}
						if (b_03_前摇结束通知.解除技能陷阱 && 技能来源 is 陷阱实例 陷阱实例)
						{
							陷阱实例.陷阱消失处理();
						}
					}
				}
				else
				{
					bool flag2 = false;
					if (!触发Buff.角色自身添加)
					{
						bool flag3 = true;
						if (触发Buff.验证自身Buff)
						{
							if (技能来源.Buff列表.ContainsKey(触发Buff.自身Buff编号))
							{
								if (触发Buff.触发成功移除)
								{
									技能来源.移除Buff时处理(触发Buff.自身Buff编号);
								}
								if (触发Buff.移除伴生Buff)
								{
									技能来源.移除Buff时处理(触发Buff.移除伴生编号);
								}
							}
							else
							{
								flag3 = false;
							}
						}
						if (flag3 && 触发Buff.验证分组Buff && 技能来源.Buff列表.Values.FirstOrDefault((Buff数据 O) => O.Buff分组 == 触发Buff.Buff分组编号) == null)
						{
							flag3 = false;
						}
						if (flag3 && 触发Buff.验证铭文技能 && 技能来源 is 玩家实例 玩家实例9)
						{
							int num18 = (int)触发Buff.所需铭文编号 / 10;
							int num19 = (int)触发Buff.所需铭文编号 % 10;
							flag3 = 玩家实例9.主体技能表.TryGetValue((ushort)num18, out var v7) && (触发Buff.同组铭文无效 ? (num19 == v7.铭文编号) : (num19 == 0 || num19 == v7.铭文编号));
						}
						if (flag3)
						{
							foreach (KeyValuePair<int, 命中详情> item25 in 命中列表)
							{
								bool flag4 = true;
								if ((item25.Value.技能反馈 & (技能命中反馈.闪避 | 技能命中反馈.丢失)) != 0)
								{
									flag4 = false;
								}
								if (flag4 && !计算类.计算概率(触发Buff.Buff触发概率))
								{
									flag4 = false;
								}
								if (flag4 && 触发Buff.验证目标类型 && !item25.Value.技能目标.特定类型(技能来源, 触发Buff.所需目标类型))
								{
									flag4 = false;
								}
								if (flag4 && 触发Buff.验证目标Buff)
								{
									flag4 = item25.Value.技能目标.Buff列表.TryGetValue(触发Buff.目标Buff编号, out var v8) && v8.当前层数.V >= 触发Buff.所需Buff层数;
								}
								if (flag4)
								{
									item25.Value.技能目标.添加Buff时处理(触发Buff.触发Buff编号, 技能来源);
									if (触发Buff.伴生Buff编号 > 0)
									{
										item25.Value.技能目标.添加Buff时处理(触发Buff.伴生Buff编号, 技能来源);
									}
									flag2 = true;
								}
							}
						}
					}
					else
					{
						bool flag5 = true;
						if (!计算类.计算概率(触发Buff.Buff触发概率))
						{
							flag5 = false;
						}
						if (flag5 && 触发Buff.验证铭文技能 && 技能来源 is 玩家实例 玩家实例10)
						{
							int num20 = (int)触发Buff.所需铭文编号 / 10;
							int num21 = (int)触发Buff.所需铭文编号 % 10;
							flag5 = 玩家实例10.主体技能表.TryGetValue((ushort)num20, out var v9) && (触发Buff.同组铭文无效 ? (num21 == v9.铭文编号) : (num21 == 0 || num21 == v9.铭文编号));
						}
						if (flag5 && 触发Buff.验证自身Buff)
						{
							if (!技能来源.Buff列表.ContainsKey(触发Buff.自身Buff编号))
							{
								flag5 = false;
							}
							else
							{
								if (触发Buff.触发成功移除)
								{
									技能来源.移除Buff时处理(触发Buff.自身Buff编号);
								}
								if (触发Buff.移除伴生Buff)
								{
									技能来源.移除Buff时处理(触发Buff.移除伴生编号);
								}
							}
						}
						if (flag5 && 触发Buff.验证分组Buff && 技能来源.Buff列表.Values.FirstOrDefault((Buff数据 O) => O.Buff分组 == 触发Buff.Buff分组编号) == null)
						{
							flag5 = false;
						}
						if (flag5 && 触发Buff.验证目标Buff && 命中列表.Values.FirstOrDefault((命中详情 O) => (O.技能反馈 & 技能命中反馈.闪避) == 0 && (O.技能反馈 & 技能命中反馈.丢失) == 0 && O.技能目标.Buff列表.TryGetValue(触发Buff.目标Buff编号, out var v10) && v10.当前层数.V >= 触发Buff.所需Buff层数) == null)
						{
							flag5 = false;
						}
						if (flag5 && 触发Buff.验证目标类型 && 命中列表.Values.FirstOrDefault((命中详情 O) => (O.技能反馈 & 技能命中反馈.闪避) == 0 && (O.技能反馈 & 技能命中反馈.丢失) == 0 && O.技能目标.特定类型(技能来源, 触发Buff.所需目标类型)) == null)
						{
							flag5 = false;
						}
						if (flag5)
						{
							技能来源.添加Buff时处理(触发Buff.触发Buff编号, 技能来源);
							if (触发Buff.伴生Buff编号 > 0)
							{
								技能来源.添加Buff时处理(触发Buff.伴生Buff编号, 技能来源);
							}
							flag2 = true;
						}
					}
					if (flag2 && 触发Buff.增加技能经验 && 技能来源 is 玩家实例 玩家实例11)
					{
						玩家实例11.技能增加经验(触发Buff.经验技能编号);
					}
				}
			}
		}
		if (节点列表.Count != 0)
		{
			预约时间 = 释放时间.AddMilliseconds(飞行耗时 + 节点列表.First().Key);
			处理任务();
		}
		else
		{
			技能来源.技能任务.Remove(this);
		}
	}

	public void 技能中断()
	{
		节点列表.Clear();
		技能来源.发送封包(new 技能释放中断
		{
			对象编号 = ((目标借位 && 技能目标 != null) ? 技能目标.地图编号 : 技能来源.地图编号),
			技能编号 = 技能编号,
			技能等级 = 技能等级,
			技能铭文 = 铭文编号,
			动作编号 = 动作编号,
			技能分段 = 分段编号
		});
	}

	static 技能实例()
	{
	}
}
